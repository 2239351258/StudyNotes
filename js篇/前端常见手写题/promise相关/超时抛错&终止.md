### 超时抛错

题意：封装一个工具函数输入一个promiseA返回一个promiseB如果超过1s没返回则抛出异常如果正常则输出正确的值。

```js
function timeOverPromise(prom, timeOver) {
  const timeOverProm = new Promise((res, rej) => {
    setTimeout(() => {
      rej(new Error(`Promise timed out after ${timeOver} ms`))
    },timeOver)
  })
  return Promise.race([prom,timeOverProm])
}

function _timeOverPromise(prom, timeOver) {
  return new Promise((res, rej) => {
    let timer=setTimeout(() => {
      rej(new Error(`Promise timed out after ${timeOver} ms`))
    }, timeOver)
    prom.then((result) => {
      clearTimeout(timer)
      res(result)
    }).catch((err) => {
      clearTimeout(timer)
      rej(err)
    })
  })
}

!(() => {
  let prom = new Promise((res, rej) => {
    setTimeout(() => {
      rej(3000)
    },1000)
  })
  _timeOverPromise(prom, 1000).then(res => console.log({ res }),rej=>console.log({rej}))
})()
```

### 超时终止

请求5s未完成就终止

```js
function timeOverEnd(url, timeOver = 500) {
  let controller = new AbortController()
  let signal = controller.signal
  let requestPromise = (url) => {
    return fetch(url, {
      signal: signal
    });
  };

  const timeOverProm = new Promise((res, rej) => {
    setTimeout(() => {
      rej(new Response("timeout", { status: 504, statusText: "timeout" }))
      controller.abort();
    }, timeOver)
  })
  
  return Promise.race([requestPromise(url), timeOverProm])
}

!(() => {
  timeOverEnd('https://www.baidu.com').then(resp => {
    console.log(resp);
  })
  .catch(error => {
    console.log(error);
  });
})()
```

